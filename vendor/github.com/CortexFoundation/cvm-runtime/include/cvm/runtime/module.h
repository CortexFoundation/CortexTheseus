/*!
 *  Copyright (c) 2017 by Contributors
 * \file cvm/runtime/module.h
 * \brief Runtime container of the functions generated by CVM,
 *  This is used to support dynamically link, load and save
 *  functions from different convention under unified API.
 */
#ifndef CVM_RUNTIME_MODULE_H_
#define CVM_RUNTIME_MODULE_H_

#include <utils/io.h>
#include <memory>
#include <vector>
#include <string>
#include <unordered_map>
#include "c_runtime_api.h"

namespace cvm {
namespace runtime {

// The internal container of module.
class ModuleNode;
class PackedFunc;

/*!
 * \brief Module container of CVM.
 */
class Module {
 public:
  Module() {}
  // constructor from container.
  explicit Module(std::shared_ptr<ModuleNode> n)
      : node_(n) {}
  /*!
   * \brief Get packed function from current module by name.
   *
   * \param name The name of the function.
   * \param query_imports Whether also query dependency modules.
   * \return The result function.
   *  This function will return PackedFunc(nullptr) if function do not exist.
   * \note Implemented in packed_func.cc
   */
  inline PackedFunc GetFunction(const std::string& name, bool query_imports = false);
  /*! \return internal container */
  inline ModuleNode* operator->();
  /*! \return internal container */
  inline const ModuleNode* operator->() const;

 private:
  std::shared_ptr<ModuleNode> node_;
};

/*!
 * \brief Base node container of module.
 *  Do not create this directly, instead use Module.
 */
class ModuleNode {
 public:
  /*! \brief virtual destructor */
  virtual ~ModuleNode() {}
  /*! \return The module type key */
  virtual const char* type_key() const = 0;
  /*!
   * \brief Get a PackedFunc from module.
   *
   *  The PackedFunc may not be fully initialized,
   *  there might still be first time running overhead when
   *  executing the function on certain devices.
   *  For benchmarking, use prepare to eliminate
   *
   * \param name the name of the function.
   * \param sptr_to_self The shared_ptr that points to this module node.
   *
   * \return PackedFunc(nullptr) when it is not available.
   *
   * \note The function will always remain valid.
   *   If the function need resource from the module(e.g. late linking),
   *   it should capture sptr_to_self.
   */
  virtual PackedFunc GetFunction(const std::string& name) = 0;

 protected:
  friend class Module;
};

// implementations of inline functions.
inline ModuleNode* Module::operator->() {
  return node_.get();
}

inline const ModuleNode* Module::operator->() const {
  return node_.get();
}

}  // namespace runtime
}  // namespace cvm

#include "packed_func.h"
#endif  // CVM_RUNTIME_MODULE_H_
