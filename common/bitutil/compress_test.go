// Copyright 2017 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.

package bitutil

import (
	"bytes"
	"math/rand"
	"testing"

	"github.com/ethereum/go-ethereum/common/hexutil"
)

// Tests that data compression and decompression works correctly.
func TestCompressCycle(t *testing.T) {
	tests := []string{
		// Tests generated by go-fuzz to maximize code coverage
		"0x000000000000000000",
		"0xef0400",
		"0xdf7070533534333636313639343638373532313536346c1bc33339343837313070706336343035336336346c65fefb3930393233383838ac2f65fefb",
		"0x7b64000000",
		"0x000034000000000000",
		"0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f0000000000000000000",
		"0x4912385c0e7b64000000",
		"0x000034000000000000000000000000000000",
		"0x00",
		"0x000003e834ff7f0000",
		"0x0000",
		"0x0000000000000000000000000000000000000000000000000000000000ff00",
		"0x895f0c6a020f850c6a020f85f88df88d",
		"0xdf7070533534333636313639343638373432313536346c1bc3315aac2f65fefb",
		"0x0000000000",
		"0xdf70706336346c65fefb",
		"0x00006d643634000000",
		"0xdf7070533534333636313639343638373532313536346c1bc333393438373130707063363430353639343638373532313536346c1bc333393438336336346c65fe",
	}
	for i, tt := range tests {
		data := hexutil.MustDecode(tt)

		proc, err := DecompressBytes(CompressBytes(data), len(data))
		if err != nil {
			t.Errorf("test %d: failed to decompress compressed data: %v", i, err)
			continue
		}
		if !bytes.Equal(data, proc) {
			t.Errorf("test %d: compress/decompress mismatch: have %x, want %x", i, proc, data)
		}
	}
}

// Tests that data decompression works
func TestDecompress(t *testing.T) {
	tests := []struct {
		size  int
		input string
		fail  error
	}{
		{size: 0, input: "0x"},

		// Crashers generated by go-fuzz
		{size: 0, input: "0x0020", fail: ErrUnreferencedData},
		{size: 0, input: "0x30", fail: ErrUnreferencedData},
		{size: 1, input: "0x00", fail: ErrUnreferencedData},
		{size: 2, input: "0x07", fail: ErrMissingData},
		{size: 1024, input: "0x8000", fail: ErrZeroContent},

		// Tests generated by go-fuzz to maximize code coverage
		{size: 29490, input: "0x343137343733323134333839373334323073333930783e3078333930783e70706336346c65303e", fail: ErrMissingData},
		{size: 59395, input: "0x00", fail: ErrUnreferencedData},
		{size: 52574, input: "0x70706336346c65c0de", fail: ErrExceededTarget},
		{size: 42264, input: "0x07", fail: ErrMissingData},
		{size: 52, input: "0xa5045bad48f4", fail: ErrExceededTarget},
		{size: 52574, input: "0xc0de", fail: ErrMissingData},
		{size: 52574, input: "0x"},
		{size: 29490, input: "0x34313734373332313433383937333432307333393078073034333839373334323073333930783e3078333937333432307333393078073061333930783e70706336346c65303e", fail: ErrMissingData},
		{size: 29491, input: "0x3973333930783e30783e", fail: ErrMissingData},

		{size: 1024, input: "0x808080608080"},
		{size: 1024, input: "0x808470705e3632383337363033313434303137393130306c6580ef46806380635a80"},
		{size: 1024, input: "0x8080808070"},
		{size: 1024, input: "0x808070705e36346c6580ef46806380635a80"},
		{size: 1024, input: "0x80808046802680"},
		{size: 1024, input: "0x4040404035"},
		{size: 1024, input: "0x4040bf3ba2b3f684402d353234373438373934409fe5b1e7ada94ebfd7d0505e27be4035"},
		{size: 1024, input: "0x404040bf3ba2b3f6844035"},
		{size: 1024, input: "0x40402d35323437343837393440bfd7d0505e27be4035"},
	}
	for i, tt := range tests {
		data := hexutil.MustDecode(tt.input)

		orig, err := DecompressBytes(data, tt.size)
		if err != tt.fail {
			t.Errorf("test %d: failure mismatch: have %v, want %v", i, err, tt.fail)
		}
		if err != nil {
			continue
		}
		if comp := CompressBytes(orig); !bytes.Equal(comp, data) {
			t.Errorf("test %d: decompress/compress mismatch: have %x, want %x", i, comp, data)
		}
	}
}

// Crude benchmark for compressing random slices of bytes.
func BenchmarkCompress1KBVerySparse(b *testing.B) { benchmarkCompress(b, 1024, 0.0001) }
func BenchmarkCompress2KBVerySparse(b *testing.B) { benchmarkCompress(b, 2048, 0.0001) }
func BenchmarkCompress4KBVerySparse(b *testing.B) { benchmarkCompress(b, 4096, 0.0001) }

func BenchmarkCompress1KBSparse(b *testing.B) { benchmarkCompress(b, 1024, 0.001) }
func BenchmarkCompress2KBSparse(b *testing.B) { benchmarkCompress(b, 2048, 0.001) }
func BenchmarkCompress4KBSparse(b *testing.B) { benchmarkCompress(b, 4096, 0.001) }

func BenchmarkCompress1KBDense(b *testing.B) { benchmarkCompress(b, 1024, 0.1) }
func BenchmarkCompress2KBDense(b *testing.B) { benchmarkCompress(b, 2048, 0.1) }
func BenchmarkCompress4KBDense(b *testing.B) { benchmarkCompress(b, 4096, 0.1) }

func BenchmarkCompress1KBSaturated(b *testing.B) { benchmarkCompress(b, 1024, 0.5) }
func BenchmarkCompress2KBSaturated(b *testing.B) { benchmarkCompress(b, 2048, 0.5) }
func BenchmarkCompress4KBSaturated(b *testing.B) { benchmarkCompress(b, 4096, 0.5) }

func benchmarkCompress(b *testing.B, bytes int, fill float64) {
	// Generate a random slice of bytes to compress
	random := rand.NewSource(0) // reproducible and comparable

	data := make([]byte, bytes)
	bits := int(float64(bytes) * 8 * fill)

	for i := 0; i < bits; i++ {
		idx := random.Int63() % int64(len(data))
		bit := uint(random.Int63() % 8)
		data[idx] |= 1 << bit
	}
	// Reset the benchmark and measure compression/decompression
	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		DecompressBytes(CompressBytes(data), len(data))
	}
}
